## Лабораторная работа 5. Анализ данных с помощью SQL

### Задание
* Создать базу данных movies_rating.db с помощью SQL-скрипта db_init.sql, подготовленного в л/р 2. **Данный скрипт должен отрабатывать за не более чем 2 секунды!**
* Составить SQL-запросы для анализа данных из movies_rating.db с использованием оконных функций.

1. Для каждого фильма выведите его название, год выпуска и средний рейтинг. Дополнительно добавьте столбец rank_by_avg_rating, в котором укажите ранг фильма среди всех фильмов по убыванию среднего рейтинга (фильмы с одинаковым средним рейтингом должны получить одинаковый ранг). Используйте оконную функцию RANK() или DENSE_RANK(). В результирующем наборе данных оставить 10 фильмов с наибольшим рангом.

2. С помощью рекурсивного CTE выделить все жанры фильмов, имеющиеся в таблице movies. Для каждого жанра рассчитать средний рейтинг avg_rating фильмов в этом жанре. Выведите genre, avg_rating и ранг жанра по убыванию среднего рейтинга, используя оконную функцию RANK().

3. Посчитайте количество фильмов в каждом жанре. Выведите два столбца: genre и movie_count, отсортировав результат по убыванию количества фильмов.

4. Найдите жанры, в которых чаще всего оставляют теги (комментарии). Для этого подсчитайте общее количество записей в таблице tags для фильмов каждого жанра. Выведите genre, tag_count и долю этого жанра в общем числе тегов (tag_share), выраженную в процентах.

5. Для каждого пользователя рассчитайте: общее количество выставленных оценок, средний выставленный рейтинг, дату первой и последней оценки (по полю timestamp в таблице ratings). Выведите user_id, rating_count, avg_rating, first_rating_date, last_rating_date. Отсортируйте результат по убыванию количества оценок и выведите только 10 первых строк.

6. Сегментируйте пользователей по типу поведения:
* «Комментаторы» — пользователи, у которых количество тегов (tags) больше количества оценок (ratings),
* «Оценщики» — наоборот, оценок больше, чем тегов,
* «Активные» — и оценок, и тегов ≥ 10,
* «Пассивные» — и оценок, и тегов < 5.
Выведите user_id, общее число оценок, общее число тегов и категорию поведения. Используйте CASE.

7. Для каждого пользователя выведите его имя и последний фильм, который он оценил (по времени из ratings.timestamp). Если пользователь не оценивал ни одного фильма, он всё равно должен быть в результате (с NULL в полях фильма).
Результат: user_id, name, last_rated_movie_title, last_rating_timestamp.

* Создание базы данных movies_rating.db, заполнение её данными, описание каждого задания и выполнение запроса для его решения оформить в виде кроссплатформенного shell-скрипта task5.bat следующего вида:
```
#!/bin/bash
chcp 65001

sqlite3 movies_rating.db < db_init.sql

echo "1. Текст первого задания... "
echo --------------------------------------------------
sqlite3 movies_rating.db -box -echo "SELECT ..."
echo " "

echo "2. Текст второго задания ..."
echo --------------------------------------------------
sqlite3 movies_rating.db -box -echo "SELECT ..."
```
* Файл task5.bat должен быть в кодировке UTF-8.
* Текст после команды `echo` должен быть заключен в двойные кавычки.
* После добавления файла task5.bat в индекс локального репозитория Git (то есть после выполнения команды `git add ...`) нужно сделать этот файл исполняемым для Linux: `git update-index --chmod=+x task5.bat`.


* * *
### Требования к оформлению и коду
* Работать нужно в ветке Task05 Git-репозитория.
* В каталоге Task05 должны быть два файла: db_init.sql и task5.bat.

* * *

### Отправка задания на проверку
Процедура отправки задания на проверку и манипуляции с репозиториями после проверки описаны в файле [Git_instruction.md](Git_instruction.md).

